/*
 * Copyright 2018 Raymond Dodge
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer;

import java.util.ArrayList;
import java.util.Map;
import java.util.function.BinaryOperator;

import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.beans.value.WritableDoubleValue;
import javafx.geometry.Point2D;
import javafx.util.Duration;

import name.rayrobdod.fightStage.unitAnimationGroup.util.*;

<%
	List<String> pointFields = [
		"leftFoot", "rightFoot", "leftKnee", "rightKnee", "leftPelvic", "rightPelvic",
		"leftHand", "rightHand", "leftElbow", "rightElbow", "leftShoulder", "rightShoulder",
		"head", "lanceCenter"
	]
	List<String> doubleFields = [
		"lanceAngle", "lanceTipDistance", "lanceButtDistance"
	]
%>

final class LancerTimelineBuilder {
	private final WritableLancerControlPoints keys;
	private LancerControlPoints values;
	private final ArrayList<KeyFrame> completedFrames;
	private Duration currentFrameTime;
	private ArrayList<KeyValue> currentFrame;
	
	
	public LancerTimelineBuilder(WritableLancerControlPoints keys, LancerControlPoints initialValues) {
		this.keys = keys;
		this.values = initialValues;
		this.completedFrames = new ArrayList<>();
		this.currentFrameTime = Duration.ZERO;
		this.currentFrame = new ArrayList<>(java.util.Arrays.asList(
			<%
				print pointFields.stream().flatMap({attr ->
					java.util.stream.Stream.of("X", "Y").map({dir ->
						"new KeyValue(keys.${attr}.writable${dir}, values.${attr}.get${dir}(), Interpolator.DISCRETE)"
					})
				}).collect(java.util.stream.Collectors.joining(",\n\t\t\t"))
				print ",\n\t\t\t"
				print doubleFields.stream().map({attr ->
					"new KeyValue(keys.${attr}, values.${attr}, Interpolator.DISCRETE)"
				}).collect(java.util.stream.Collectors.joining(",\n\t\t\t"))
			%>
		));
	}
	
	public LancerTimelineBuilder(WritableLancerControlPoints keys, Map<WritableDoubleValue, Double> store) {
		this(keys, extractFromMap(store, keys));
	}
	
	public LancerControlPoints currentValues() {return values;}
	public Timeline timeline() {
		if (! currentFrame.isEmpty()) {
			completedFrames.add(new KeyFrame(currentFrameTime, null, null, currentFrame));
			currentFrame = new ArrayList<>();
		}
		return new Timeline(completedFrames.stream().toArray(KeyFrame[]::new));
	}
	
	public void nextFrame(Duration deltaTime) {
		completedFrames.add(new KeyFrame(currentFrameTime, null, null, currentFrame));
		currentFrameTime = currentFrameTime.add(deltaTime);
		currentFrame = new ArrayList<>();
	}
	
	public void storeInMap(Map<WritableDoubleValue, Double> store) {
		<%
			print pointFields.stream().flatMap({attr ->
				java.util.stream.Stream.of("X", "Y").map({dir ->
					"store.put(keys.${attr}.writable${dir}, values.${attr}.get${dir}());\n\t\t\t"
				})
			}).collect(java.util.stream.Collectors.joining());
			print doubleFields.stream().map({s -> "store.put(keys.${s}, values.${s});\n\t\t\t"}).collect(java.util.stream.Collectors.joining());
		%>
	}
	
	private static LancerControlPoints extractFromMap(Map<WritableDoubleValue, Double> store, WritableLancerControlPoints keys) {
		return new LancerControlPoints(
			<%
				print pointFields.stream().map(
					{s -> """new Point2D(store.get(keys.${s}.writableX), store.get(keys.${s}.writableY))"""}
				).collect(java.util.stream.Collectors.joining(",\n\t\t\t"))
				print ",\n\t\t\t"
				print doubleFields.stream().map(
					{s -> """store.get(keys.${s})"""}
				).collect(java.util.stream.Collectors.joining(",\n\t\t\t"))
			%>
		);
	}
	
	<%
		print pointFields.stream().map({s ->
			String sTitle = "${s.charAt(0).toUpperCase()}${s.substring(1)}"
			"""public void set${sTitle}(Point2D value, Interpolator interp) {
				this.values = this.values.copyWith${sTitle}(value);
				this.currentFrame.add(new KeyValue(keys.${s}.writableX, value.getX(), interp));
				this.currentFrame.add(new KeyValue(keys.${s}.writableY, value.getY(), interp));
			}
			"""
		}).collect(java.util.stream.Collectors.joining())
		print doubleFields.stream().map({s ->
			String sTitle = "${s.charAt(0).toUpperCase()}${s.substring(1)}"
			"""public void set${sTitle}(double value, Interpolator interp) {
				this.values = this.values.copyWith${sTitle}(value);
				this.currentFrame.add(new KeyValue(keys.${s}, value, interp));
			}
			"""
		}).collect(java.util.stream.Collectors.joining())
	%>
	<%
		print pointFields.stream().map({s ->
			String sTitle = "${s.charAt(0).toUpperCase()}${s.substring(1)}"
			"""public void add${sTitle}(Point2D value, Interpolator interp) {
				this.set${sTitle}(this.values.${s}.add(value), interp);
			}
			"""
		}).collect(java.util.stream.Collectors.joining())
		print doubleFields.stream().map({s ->
			String sTitle = "${s.charAt(0).toUpperCase()}${s.substring(1)}"
			"""public void add${sTitle}(double value, Interpolator interp) {
				this.set${sTitle}(this.values.${s} + value, interp);
			}
			"""
		}).collect(java.util.stream.Collectors.joining())
	%>
	
	<%
		String[][] adjacentPairs = [
			["leftKnee", "leftFoot"],
			["rightKnee", "rightFoot"],
			["leftPelvic", "leftKnee"],
			["rightPelvic", "rightKnee"],
			
			["leftFoot", "leftKnee"],
			["rightFoot", "rightKnee"],
			["leftKnee", "leftPelvic"],
			["rightKnee", "rightPelvic"],
			["leftPelvic", "rightPelvic"],
			["rightPelvic", "leftPelvic"],
			
			["leftShoulder", "leftPelvic"],
			["rightShoulder", "rightPelvic"],
			["leftElbow", "leftShoulder"],
			["rightElbow", "rightShoulder"],
			["leftHand", "leftElbow"],
			["rightHand", "rightElbow"],
			["lanceCenter", "rightHand"],
		]
		
		for (String[] adjacentPair : adjacentPairs) {
			String target = adjacentPair[0];
			String source = adjacentPair[1];
			String targetTitle = target.substring(0, 1).toUpperCase() + target.substring(1);
			String sourceTitle = source.substring(0, 1).toUpperCase() + source.substring(1);
			
			print """public void set${targetTitle}RelativeTo${sourceTitle}(Point2D delta, Interpolator interp) {
				this.set${targetTitle}(this.values.${source}.add(delta), interp);
			}
			"""
		}
	%>
	
	public void setHeadRelativeToShoulders(BinaryOperator<Point2D> op, Interpolator interp) {
		this.setHead(op.apply(this.values.leftShoulder, this.values.rightShoulder), interp);
	}
	
	public void setRightKneeRelativeToRightLeg(BinaryOperator<Point2D> op, Interpolator interp) {
		this.setRightKnee(op.apply(this.values.rightPelvic, this.values.rightFoot), interp);
	}
	
	public void setLeftKneeRelativeToLeftLeg(BinaryOperator<Point2D> op, Interpolator interp) {
		this.setLeftKnee(op.apply(this.values.leftPelvic, this.values.leftFoot), interp);
	}
	
	public void setRightElbowRelativeToRightArm(BinaryOperator<Point2D> op, Interpolator interp) {
		this.setRightElbow(op.apply(this.values.rightShoulder, this.values.rightHand), interp);
	}
	
	public void setLeftElbowRelativeToLeftArm(BinaryOperator<Point2D> op, Interpolator interp) {
		this.setLeftElbow(op.apply(this.values.leftShoulder, this.values.leftHand), interp);
	}
	
	public void setLeftHandRelativeToLance(double distance, Interpolator interp) {
		this.setLeftHand(this.values.lanceCenter.add(Point2Ds.polar(distance, this.values.lanceAngle)), interp);
	}
	
	public void setRightHandRelativeToLance(double distance, Interpolator interp) {
		this.setRightHand(this.values.lanceCenter.add(Point2Ds.polar(distance, this.values.lanceAngle)), interp);
	}
	
	public void setLanceAngleToPointAt(Point2D target, Interpolator interp) {
		Point2D delta = target.subtract(this.values.lanceCenter);
		double deltaAngle = Math.atan2(delta.getY(), delta.getX());
		while (deltaAngle < Math.PI / 4) {deltaAngle += Math.PI * 2;}
		while (deltaAngle > Math.PI * 9 / 4) {deltaAngle -= Math.PI * 2;}
		this.setLanceAngle(deltaAngle, interp);
	}
}

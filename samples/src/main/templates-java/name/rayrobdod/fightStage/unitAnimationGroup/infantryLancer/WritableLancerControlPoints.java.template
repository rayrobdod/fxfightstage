/*
 * Copyright 2018 Raymond Dodge
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer;

import static name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer.Point2dBinding.createPoint2dBinding;
import static name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer.Point2dPathElements.newBoundCubicCurveTo;
import static name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer.Point2dPathElements.newBoundLineTo;
import static name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer.Point2dPathElements.newBoundMoveTo;

import javafx.beans.value.ObservableValue;
import javafx.geometry.Point2D;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.shape.ClosePath;
import javafx.scene.shape.Path;

final class WritableLancerControlPoints {
	public final WritablePoint2dValue ${fields.join(";\n\tpublic final WritablePoint2dValue ")};
	
	public WritableLancerControlPoints() {
		<%
			for (String field : fields) {
				print "this."
				print field
				print " = new WritablePoint2dValue();\n\t\t"
			}
		%>
	}
	
	
	
	
	
	private static final double LANCE_HALFWIDTH = 3;
	private static final double LEG_HALFWIDTH = 7;
	private static final double ARM_HALFWIDTH = 5;
	
	public Node createStickFigure() {
		final Path retval = new Path(
			  newBoundMoveTo(this.leftFoot)
			, newBoundLineTo(this.leftKnee)
			, newBoundLineTo(this.leftPelvic)
			, newBoundLineTo(this.rightPelvic)
			, newBoundLineTo(this.rightKnee)
			, newBoundLineTo(this.rightFoot)
			, newBoundMoveTo(this.leftHand)
			, newBoundLineTo(this.leftElbow)
			, newBoundLineTo(this.leftShoulder)
			, newBoundLineTo(this.rightShoulder)
			, newBoundLineTo(this.rightElbow)
			, newBoundLineTo(this.rightHand)
			, newBoundMoveTo(this.rightPelvic)
			, newBoundLineTo(this.rightShoulder)
			, newBoundLineTo(this.head)
			, newBoundLineTo(this.leftShoulder)
			, newBoundLineTo(this.leftPelvic)
		);
		retval.setStroke(Color.BLACK);
		retval.setFill(Color.TRANSPARENT);
		retval.setStrokeWidth(2);
		return retval;
	}
	
	public Node createLance() {
		final Point2dExpression center = this.lanceCenter;
		final Point2dExpression direction = center.subtract(this.lanceControl).normalize();
		final Point2dExpression perp = direction.perpendicular();
		
		
		final Path shaft = new Path(
			  newBoundMoveTo(center.add(direction.multiply(60)).add(perp.multiply(LANCE_HALFWIDTH)))
			, newBoundLineTo(center.add(direction.multiply(60)).add(perp.multiply(-LANCE_HALFWIDTH)))
			, newBoundLineTo(center.add(direction.multiply(-60)).add(perp.multiply(-LANCE_HALFWIDTH)))
			, newBoundCubicCurveTo(
				  center.add(direction.multiply(-65)).add(perp.multiply(-LANCE_HALFWIDTH))
				, center.add(direction.multiply(-65)).add(perp.multiply(LANCE_HALFWIDTH))
				, center.add(direction.multiply(-60)).add(perp.multiply(LANCE_HALFWIDTH))
			  )
			, newBoundLineTo(center.add(direction.multiply(60)).add(perp.multiply(LANCE_HALFWIDTH)))
		);
		shaft.setStroke(Color.BLACK);
		shaft.setFill(Color.BROWN);
		shaft.setStrokeWidth(1);
		
		final Path head = new Path(
			  newBoundMoveTo(center.add(direction.multiply(55)).add(perp.multiply(7.5)))
			, newBoundLineTo(center.add(direction.multiply(55)).add(perp.multiply(-7.5)))
			, newBoundLineTo(center.add(direction.multiply(70)).add(perp.multiply(0)))
			, newBoundLineTo(center.add(direction.multiply(55)).add(perp.multiply(7.5)))
		);
		head.setStroke(Color.BLACK);
		head.setFill(Color.SILVER);
		head.setStrokeWidth(1);
		
		return new Group(shaft, head);
	}
	
	public Node createPantSeat() {
		final Point2dExpression left = this.leftPelvic;
		final Point2dExpression right = this.rightPelvic;
		
		final Path leg = new Path(
			// front
			newBoundMoveTo(left.add(new Point2D(LEG_HALFWIDTH, 2))),
			newBoundLineTo(left.add(new Point2D(LEG_HALFWIDTH, -10))),
			newBoundLineTo(right.add(new Point2D(-LEG_HALFWIDTH, -10))),
			newBoundLineTo(right.add(new Point2D(-LEG_HALFWIDTH, 2))),
			new ClosePath()
		);
		leg.setStroke(Color.BLACK);
		leg.setFill(Color.BLUE);
		leg.setStrokeWidth(1);
		return leg;
	}
	
	public Node createLeftLeg() {
		return createLeg(this.leftKnee, this.leftFoot, this.leftPelvic);
	}
	
	public Node createRightLeg() {
		return createLeg(this.rightKnee, this.rightFoot, this.rightPelvic);
	}
	
	private static Node createLeg(final Point2dExpression pivot, final Point2dExpression edge1, final Point2dExpression edge2) {
		final Point2dExpression dir1 = edge1.subtract(pivot).normalize();
		final Point2dExpression perp1 = dir1.perpendicular();
		final Point2dExpression dir2 = pivot.subtract(edge2).normalize();
		final Point2dExpression perp2 = dir2.perpendicular();
		
		final Point2dExpression backOfFoot = edge1.add(perp1.multiply(LEG_HALFWIDTH)).interception(dir1, new Point2D(0,0), new Point2D(1, 0));
		final Point2dExpression backOfPelvic = edge2.add(perp2.multiply(LEG_HALFWIDTH));
		final Point2dExpression frontOfFoot = edge1.add(perp1.multiply(-LEG_HALFWIDTH)).interception(dir1, new Point2D(0,0), new Point2D(1, 0));
		final Point2dExpression frontOfPelvic = edge2.add(perp2.multiply(-LEG_HALFWIDTH));
		final Point2dExpression frontOfKnee2 = pivot.add(perp2.multiply(-LEG_HALFWIDTH));
		final Point2dExpression frontOfKnee1 = pivot.add(perp1.multiply(-LEG_HALFWIDTH));
		
		final Path leg = new Path(
			// front
			newBoundMoveTo(frontOfPelvic),
			newBoundLineTo(frontOfKnee2),
			newBoundCubicCurveTo(
				frontOfKnee2.add(dir2.multiply(frontOfKnee2.subtract(frontOfKnee1).magnitude().multiply(0.75))),
				frontOfKnee1.add(dir1.multiply(frontOfKnee1.subtract(frontOfKnee2).magnitude().multiply(-0.75))),
				frontOfKnee1
			),
			newBoundLineTo(frontOfFoot),
			// back
			newBoundLineTo(backOfFoot),
			newBoundLineTo(backOfFoot.interception(dir1, backOfPelvic, dir2)),
			newBoundLineTo(backOfPelvic)
			// not closed
		);
		leg.setStroke(Color.BLACK);
		leg.setFill(Color.BLUE);
		leg.setStrokeWidth(1);
		return leg;
	}
	
	public Node createRightArm() {
		return createArm(this.rightElbow, this.rightHand, this.rightShoulder);
	}
	
	public Node createLeftArm() {
		return createArm(this.leftElbow, this.leftHand, this.leftShoulder);
	}
	
	private static Node createArm(final Point2dExpression pivot, final Point2dExpression edge1, final Point2dExpression edge2) {
		final Point2dExpression dir1 = edge1.subtract(pivot).normalize();
		final Point2dExpression perp1 = dir1.perpendicular();
		final Point2dExpression dir2 = pivot.subtract(edge2).normalize();
		final Point2dExpression perp2 = dir2.perpendicular();
		
		
		
		final Point2dExpression topOfHand = edge1.add(perp1.multiply(ARM_HALFWIDTH));
		final Point2dExpression topOfKnee1 = pivot.add(perp1.multiply(ARM_HALFWIDTH));
		final Point2dExpression topOfKnee2 = pivot.add(perp2.multiply(ARM_HALFWIDTH));
		final Point2dExpression topOfShoulder = edge2.add(perp2.multiply(ARM_HALFWIDTH));
		final Point2dExpression bottomOfHand = edge1.add(perp1.multiply(-ARM_HALFWIDTH));
		final Point2dExpression bottomOfKnee1 = pivot.add(perp1.multiply(-ARM_HALFWIDTH));
		final Point2dExpression bottomOfKnee2 = pivot.add(perp2.multiply(-ARM_HALFWIDTH));
		final Point2dExpression bottomOfShoulder = edge2.add(perp2.multiply(-ARM_HALFWIDTH));
		
		final Path leg = new Path(
			// front
			newBoundMoveTo(topOfShoulder),
			newBoundLineTo(roundJoinPoint(pivot, topOfKnee1, dir1, topOfKnee2, dir2, 3)),
			newBoundCubicCurveTo(
				roundJoinPoint(pivot, topOfKnee1, dir1, topOfKnee2, dir2, 2),
				roundJoinPoint(pivot, topOfKnee1, dir1, topOfKnee2, dir2, 1),
				roundJoinPoint(pivot, topOfKnee1, dir1, topOfKnee2, dir2, 0)
			),
			newBoundLineTo(topOfHand),
			// back
			newBoundLineTo(bottomOfHand),
			newBoundLineTo(roundJoinPoint(pivot, bottomOfKnee1, dir1, bottomOfKnee2, dir2.negate(), 0)),
			newBoundCubicCurveTo(
				roundJoinPoint(pivot, bottomOfKnee1, dir1, bottomOfKnee2, dir2.negate(), 1),
				roundJoinPoint(pivot, bottomOfKnee1, dir1, bottomOfKnee2, dir2.negate(), 2),
				roundJoinPoint(pivot, bottomOfKnee1, dir1, bottomOfKnee2, dir2.negate(), 3)
			),
			newBoundLineTo(bottomOfShoulder)
			// not closed
		);
		leg.setStroke(Color.BLACK);
		leg.setFill(Color.RED);
		leg.setStrokeWidth(1);
		return leg;
	}
	
	
	public Node createLeftHand() {
		javafx.scene.shape.Circle retval = new javafx.scene.shape.Circle();
		retval.centerXProperty().bind(this.leftHand.x());
		retval.centerYProperty().bind(this.leftHand.y());
		retval.radiusProperty().set(ARM_HALFWIDTH);
		retval.setStroke(Color.BLACK);
		retval.setFill(Color.PINK);
		retval.setStrokeWidth(1);
		return retval;
	}
	
	public Node createRightHand() {
		javafx.scene.shape.Circle retval = new javafx.scene.shape.Circle();
		retval.centerXProperty().bind(this.rightHand.x());
		retval.centerYProperty().bind(this.rightHand.y());
		retval.radiusProperty().set(ARM_HALFWIDTH);
		retval.setStroke(Color.BLACK);
		retval.setFill(Color.PINK);
		retval.setStrokeWidth(1);
		return retval;
	}
	
	
	
	
	
	private static Point2D roundJoinPoint(Point2D center, Point2D edge1, Point2D dir1, Point2D edge2, Point2D dir2, int polarity) {
		Point2D intercept = Point2Ds.interception(edge1, dir1, edge2, dir2);
		double controlDistance = edge1.distance(edge2) * -0.75;
		
		if (edge1.add(dir1).distance(intercept) < edge1.distance(intercept)) {
			return intercept;
		} else {
			switch (polarity % 4) {
				case 0: return edge1;
				case 1: return edge1.add(dir1.multiply(controlDistance));
				case 2: return edge2.add(dir2.multiply(controlDistance));
				case 3: return edge2;
				default: return edge1.midpoint(edge2);
			}
		}
	}
	
	private static Point2dExpression roundJoinPoint(ObservableValue<Point2D> center, ObservableValue<Point2D> edge1, ObservableValue<Point2D> dir1, ObservableValue<Point2D> edge2, ObservableValue<Point2D> dir2, int polarity) {
		return createPoint2dBinding(() -> roundJoinPoint(center.getValue(), edge1.getValue(), dir1.getValue(), edge2.getValue(), dir2.getValue(), polarity),
					center, edge1, dir1, edge2, dir2);
	}
}

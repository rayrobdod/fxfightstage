plugins {
	id "com.diffplug.gradle.spotless" version "3.25.0"
}

/**
 * Create a new FileCollection that is similar to the input, but replaces any
 * non-directories (assumed to be zip files) with it's contents
 */
def expandZips(FileCollection inputs) {
	FileCollection retval = files()
	inputs.forEach{f ->
		if (f.isDirectory()) {
			retval = retval + files(f)
		} else {
			retval = retval + zipTree(f)
		}
	}
	return retval;
}

/**
 * Split a string by whitespace, taking quoting and escaping into account
 * @see https://stackoverflow.com/questions/20410854/how-to-pass-parameters-or-arguments-into-a-gradle-task/48370451#48370451
 */
def List<String> splitIntoTokens(String commandLine) {
	String regex = "(([\"']).*?\\2|(?:[^\\\\ ]+\\\\\\s+)+[^\\\\ ]+|\\S+)";
	java.util.regex.Matcher matcher = java.util.regex.Pattern.compile(regex).matcher(commandLine);
	ArrayList<String> result = new ArrayList<>();
	while (matcher.find()) {
		result.add(matcher.group());
	}
	return result
}

def String fxPlatform() {
	def currentOS = org.gradle.internal.os.OperatingSystem.current()
	if (currentOS.isWindows()) {
		return 'win'
	} else if (currentOS.isLinux()) {
		return 'linux'
	} else if (currentOS.isMacOsX()) {
		return 'mac'
	}
}

subprojects {
	apply plugin: 'java'
	apply plugin: "com.diffplug.gradle.spotless"
	
	sourceCompatibility = (org.gradle.api.JavaVersion.current() == org.gradle.api.JavaVersion.VERSION_1_8 ? 8 : 9)
	[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
	[compileJava, compileTestJava]*.options*.deprecation = true
	[compileJava, compileTestJava]*.options*.compilerArgs = ["-Xlint:unchecked"]
	
	group = "name.rayrobdod"
	version = 'SNAPSHOT'
	javadoc.options.overview = new File(sourceSets.main.java.srcDirs[0], 'overview.html')
	javadoc.options.addBooleanOption('Xdoclint:-syntax', true)
	if (JavaVersion.current().isJava8()) {
		javadoc.options.links("https://docs.oracle.com/javase/8/docs/api/")
		javadoc.options.links("https://docs.oracle.com/javase/8/javafx/api/")
	} else if (JavaVersion.current().isJava9()) {
		javadoc.options.links("https://docs.oracle.com/javase/9/docs/api/")
	} else if (JavaVersion.current().isJava10()) {
		javadoc.options.links("https://docs.oracle.com/javase/10/docs/api/")
	} else if (JavaVersion.current().isJava11()) {
		javadoc.options.links("https://docs.oracle.com/en/java/javase/11/docs/api/")
		javadoc.options.links("https://openjfx.io/javadoc/11/")
	} else {
		// https://download.java.net/java/early_access/jdk12/docs/api/
	}
	
	repositories {
		mavenCentral()
	}
	
	dependencies {
		testImplementation "org.junit.jupiter:junit-jupiter-api:5.1.0"
		testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:5.1.0"
		testImplementation "org.testfx:testfx-junit5:4.0.13-alpha"
	}
	
	if (! project.hasProperty("noExternalJavafx")) {
		dependencies {
			compileOnly "org.openjfx:javafx-base:11:${fxPlatform()}"
			compileOnly "org.openjfx:javafx-graphics:11:${fxPlatform()}"
			compileOnly "org.openjfx:javafx-controls:11:${fxPlatform()}"
			compileOnly "org.openjfx:javafx-swing:11:${fxPlatform()}"
			compileOnly "org.openjfx:javafx-media:11:${fxPlatform()}"
			
			testImplementation "org.openjfx:javafx-base:11:${fxPlatform()}"
			testImplementation "org.openjfx:javafx-graphics:11:${fxPlatform()}"
			testImplementation "org.openjfx:javafx-controls:11:${fxPlatform()}"
			testImplementation "org.openjfx:javafx-swing:11:${fxPlatform()}"
			testImplementation "org.openjfx:javafx-media:11:${fxPlatform()}"
		}
	}

	if (JavaVersion.current().isJava9Compatible()) {
		sourceSets {
			main {
				java {
					srcDirs 'src/main/java', 'src/main/java-9+'
				}
			}
		}
		
		compileJava {
			doFirst {
				options.compilerArgs = [
				'--module-path', classpath.asPath,
				]
				classpath = files()
			}
		}
		javadoc {
			doFirst {
				options.addStringOption('-module-path', classpath.asPath)
				classpath = files()
			}
		}
	}
	
	spotless {
		java {
			importOrder 'java', 'javax', 'javafx', 'org.junit', 'org.testfx', '', 'name.rayrobdod'
			removeUnusedImports()
			licenseHeaderFile '../spotless-license-java', 'package|module'
			endWithNewline()
			replaceRegex 'one blank line after package line', '(package .+;)\n+import', '$1\n\nimport'
			replaceRegex 'one blank line after import lists', '(import .+;\n\n)\n+', '$1'
		}
	}
	
	jar.manifest.attributes (
		  'Implementation-Title': name
		, 'Implementation-Version': version
		, 'Implementation-Vendor': group
	)
	
	task javadocJar(dependsOn: javadoc, type: Jar) {
		from(javadoc.destinationDir)
		classifier("javadoc")
	}
	assemble.dependsOn(javadocJar)
	task javadocTar(dependsOn: javadoc, type: Tar) {
		from(javadoc.destinationDir)
		destinationDirectory = javadocJar.destinationDirectory
		classifier("javadoc")
		compression(Compression.GZIP)
		archiveExtension = "tar.gz"
	}
	assemble.dependsOn(javadocTar)
	task sourceJar(type: Jar) {
		from(sourceSets.main.allSource)
		classifier("sources")
	}
	assemble.dependsOn(sourceJar)
	task sourceTar(type: Tar) {
		from(sourceSets.main.allSource)
		destinationDirectory = sourceJar.destinationDirectory
		classifier("sources")
		compression(Compression.GZIP)
		archiveExtension = "tar.gz"
	}
	assemble.dependsOn(sourceTar)
	
	artifacts {
		archives javadocJar
		archives sourceJar
	}
	
	// Run the thing that will tell me why the java will not compile
	// before running the thing that doesn't tell my why the java
	//     will not compile and prevents the first thing from running
	tasks.withType(com.diffplug.gradle.spotless.SpotlessTask) {mtask ->
		mtask.mustRunAfter(compileJava)
		mtask.mustRunAfter(compileTestJava)
	}
	
	test {
		enableAssertions = true
		useJUnitPlatform {
			// the `robot` tag refers to tests that make use of `org.testfx.api.FxRobot`
			// This hijacks a user's cursor for the duration of the tests, which may be undesirable
			if (project.hasProperty("excludeRobotTests")) {
				excludeTags 'robot'
			}
		}
	}
}

project(":core") {
	project.ext.mainClassName = null
	project.ext.artifactId = "fxfightstage"
	
	jar.manifest.attributes (
		  'Automatic-Module-Name': 'name.rayrobdod.fightStage.core'
		, 'Implementation-Title': project.ext.artifactId
	)
}

project(":demo") {
	project.ext.mainClassName = null
	project.ext.artifactId = "fxfightstage-demo"
	
	//TODO: convert to linksOffline after deciding where these will be online
	javadoc.options.links(project(":core").javadoc.destinationDir.toURI().toString())
	
	dependencies {
		implementation project(":core")
	}
	
	jar.manifest.attributes (
		  'Automatic-Module-Name': 'name.rayrobdod.fightStage.demo'
		, 'Implementation-Title': project.ext.artifactId
	)
}

project(":samples") {
	project.ext.mainClassName = "name.rayrobdod.fightStage.previewer.Main"
	project.ext.artifactId = "fxfightstage-samples"
	
	//TODO: convert to linksOffline after deciding where these will be online
	javadoc.options.links(project(":core").javadoc.destinationDir.toURI().toString())
	javadoc.options.links(project(":demo").javadoc.destinationDir.toURI().toString())
	
	dependencies {
		implementation project(":core")
		implementation project(":demo")
		testImplementation project(":core").sourceSets.test.output
	}
	
	if (! project.hasProperty("noExternalJavafx")) {
		dependencies {
			implementation "org.openjfx:javafx-base:11:${fxPlatform()}"
			implementation "org.openjfx:javafx-graphics:11:${fxPlatform()}"
			implementation "org.openjfx:javafx-controls:11:${fxPlatform()}"
			implementation "org.openjfx:javafx-swing:11:${fxPlatform()}"
			implementation "org.openjfx:javafx-media:11:${fxPlatform()}"
		}
	}
	
	jar.manifest.attributes (
		  'Main-Class': project.mainClassName
		, 'Automatic-Module-Name': 'name.rayrobdod.fightStage.samples'
		, 'Implementation-Title': project.ext.artifactId
	)
	
	task run(dependsOn: classes, type: JavaExec) {
		main = project.mainClassName
		classpath = sourceSets.main.runtimeClasspath
		args = splitIntoTokens(project.hasProperty("args") ? project.args : "")
		standardInput = System.in
		ignoreExitValue = true
	}
	
	//example: `gradlew runRasterize "-Pargs=--spell=Tornado --d=out.png --fps=60 --bitDepth=8 --no-smooth"`
	task runRasterize(dependsOn: classes, type: JavaExec) {
		main = "name.rayrobdod.fightStage.rasterizer.Main"
		classpath = sourceSets.main.runtimeClasspath
		args = splitIntoTokens(project.hasProperty("args") ? project.args : "")
		standardInput = System.in
		ignoreExitValue = true
	}
	if (JavaVersion.current().isJava9Compatible()) {
		run {
			doFirst {
				jvmArgs = [
					'--module-path', classpath.asPath,
					'--module', "name.rayrobdod.fightStage.demo/${project.mainClassName}"
				]
				classpath = files()
			}
		}
	}
	
	task fatjar(dependsOn: classes, type: Jar) {
		// delay execution of expandZips unitil after the classpath is created
		from({ -> expandZips(sourceSets.main.runtimeClasspath)})
		archiveBaseName = "FxFightStageSamples"
		archiveVersion = ""
		destinationDirectory = project.layout.buildDirectory.dir(project.distsDirName)
		manifest.attributes (
			  'Main-Class': project.mainClassName
			, 'Implementation-Title': (project.ext.artifactId + "-fatjar")
			, 'Implementation-Version': project.version
			, 'Implementation-Vendor': project.group
		)
	}
	assemble.dependsOn(fatjar)

	if (JavaVersion.current().isJava9Compatible()) {
		task extractLicenseToDir(type: Copy) {
			from "$rootDir/LICENSE.txt"
			into "$buildDir/tmp/mod/legal"
		}
		task extractSoundToDir(type: Copy) {
			from "$projectDir/src/main/resources/name/rayrobdod/fightStage/sounds/swing.wav"
			into "$buildDir/tmp/mod/libs"
		}
		task mod(type: Exec) {
			def outFile = project.layout.buildDirectory.dir(project.libsDirName).map{f -> f.file("fightstage-samples.jmod")}
			dependsOn 'jar'
			dependsOn 'extractLicenseToDir'
			dependsOn 'extractSoundToDir'
			dependsOn 'cleanMod'
			workingDir buildDir
			outputs.file outFile
			
			commandLine "${System.properties.'java.home'}/bin/jmod",
					'create',
					'--class-path', "${jar.archivePath}",
					'--legal-notices', "$buildDir/tmp/mod/legal",
					'--libs', "$buildDir/tmp/mod/libs",
					outFile.get().toString()
		}
		
		
		task link(type: Exec) {
			def outFile = project.layout.buildDirectory.dir(project.distsDirName).map{f -> f.dir("jlink")}
			dependsOn 'mod'
			dependsOn 'cleanLink'
			workingDir buildDir
			outputs.file outFile
			
			commandLine "${System.properties.'java.home'}/bin/jlink",
					'--module-path', "${project.configurations.runtimeClasspath.asPath}${File.pathSeparatorChar}libs/fightstage-samples.jmod${File.pathSeparatorChar}${System.properties.'java.home'}/jmods",
					'--add-modules', 'name.rayrobdod.fightStage.samples',
					'--launcher', "samples=name.rayrobdod.fightStage.demo/${project.mainClassName}",
					'--output', outFile.get().toString(),
					//'--bind-services',
					'--strip-debug',
					'--compress', '0',
					'--no-header-files',
					'--no-man-pages'
		}
		assemble.dependsOn(link)
	}
}

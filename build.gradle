plugins {
	id "com.diffplug.gradle.spotless" version "3.10.0"
}

/**
 * Create a new FileCollection that is similar to the input, but replaces any
 * non-directories (assumed to be zip files) with it's contents
 */
def expandZips(FileCollection inputs) {
	FileCollection retval = files()
	inputs.forEach{f ->
		if (f.isDirectory()) {
			retval = retval + files(f)
		} else {
			retval = retval + zipTree(f)
		}
	}
	return retval;
}

/**
 * Split a string by whitespace, taking quoting and escaping into account
 * @see https://stackoverflow.com/questions/20410854/how-to-pass-parameters-or-arguments-into-a-gradle-task/48370451#48370451
 */
def List<String> splitIntoTokens(String commandLine) {
	String regex = "(([\"']).*?\\2|(?:[^\\\\ ]+\\\\\\s+)+[^\\\\ ]+|\\S+)";
	java.util.regex.Matcher matcher = java.util.regex.Pattern.compile(regex).matcher(commandLine);
	ArrayList<String> result = new ArrayList<>();
	while (matcher.find()) {
		result.add(matcher.group());
	}
	return result
}

// https://github.com/gradle/gradle/tree/master/subprojects/docs/src/samples/customModel/languageType
class TemplateJavaCompile extends SourceTask {
	@OutputDirectory File targetDir
	
	@TaskAction void process() {
		def encoding = "UTF-8"
		
		List<String> fields = [
			"leftFoot", "rightFoot", "leftKnee", "rightKnee", "leftPelvic", "rightPelvic",
			"leftHand", "rightHand", "leftElbow", "rightElbow", "leftShoulder", "rightShoulder",
			"head", "lanceCenter", "lanceControl"
		]
		def binding = ["fields": fields]
		def engine = new groovy.text.SimpleTemplateEngine()
		
		getSource().each {srcFile ->
	            File tarFile = new File(targetDir, srcFile.name.replace(".template", ""))
			tarFile.write(engine.createTemplate(srcFile.getText(encoding)).make(binding).toString(), encoding)
		}
	}
}

subprojects {
	apply plugin: 'java'
	apply plugin: 'maven'
	apply plugin: "com.diffplug.gradle.spotless"
	
	sourceCompatibility = 1.8
	[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
	[compileJava, compileTestJava]*.options*.deprecation = true
	[compileJava, compileTestJava]*.options*.compilerArgs = ["-Xlint:unchecked"]
	
	group = "name.rayrobdod"
	version = 'SNAPSHOT'
	javadoc.options.overview = new File(sourceSets.main.java.srcDirs[0], 'overview.html')
	javadoc.options.links("https://docs.oracle.com/javase/8/docs/api/")
	javadoc.options.links("https://docs.oracle.com/javase/8/javafx/api/")
	
	repositories {
		mavenCentral()
	}
	
	dependencies {
		testCompile("org.junit.jupiter:junit-jupiter-api:5.1.0")
		testRuntime("org.junit.jupiter:junit-jupiter-engine:5.1.0")
		testCompile "org.testfx:testfx-junit5:4.0.13-alpha"
	}

	spotless {
		java {
			target project.fileTree(project.rootDir) {
				include '**/*.java'
				exclude '**/generated/**/*.*'
			}
			importOrder 'java', 'javax', 'javafx', 'org.junit', 'org.testfx', '', 'name.rayrobdod'
			removeUnusedImports()
			licenseHeaderFile '../spotless-license-java'
			endWithNewline()
			replaceRegex 'one blank line after package line', '(package .+;)\n+import', '$1\n\nimport'
			replaceRegex 'one blank line after import lists', '(import .+;\n\n)\n+', '$1'
		}
	}
	
	jar.manifest.attributes (
		  'Implementation-Title': name
		, 'Implementation-Version': version
		, 'Implementation-Vendor': group
	)
	
	task javadocJar(dependsOn: javadoc, type: Jar) {
		from(javadoc.destinationDir)
		destinationDir(project.libsDir)
		classifier("javadoc")
	}
	assemble.dependsOn(javadocJar)
	task javadocTar(dependsOn: javadoc, type: Tar) {
		from(javadoc.destinationDir)
		destinationDir(project.libsDir)
		classifier("javadoc")
		compression(Compression.GZIP)
		extension("tar.gz")
	}
	assemble.dependsOn(javadocTar)
	task sourceJar(type: Jar) {
		from(sourceSets.main.allSource)
		destinationDir(project.libsDir)
		classifier("sources")
	}
	assemble.dependsOn(sourceJar)
	task sourceTar(type: Tar) {
		from(sourceSets.main.allSource)
		destinationDir(project.libsDir)
		classifier("sources")
		compression(Compression.GZIP)
		extension("tar.gz")
	}
	assemble.dependsOn(sourceTar)
	
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives {
			repositories {
				mavenDeployer {
					repository(url: localPublishLocation)
					pom.groupId = project.group
					pom.version = project.version
				}
			}
		}
	}
	
	artifacts {
		archives javadocJar
		archives sourceJar
	}
	
	// Run the thing that will tell me why the java will not compile
	// before running the thing that doesn't tell my why the java
	//     will not compile and prevents the first thing from running
	tasks.withType(com.diffplug.gradle.spotless.SpotlessTask) {mtask ->
		mtask.mustRunAfter(compileJava)
		mtask.mustRunAfter(compileTestJava)
	}
	
	test {
		enableAssertions = true
		useJUnitPlatform {
			// the `robot` tag refers to tests that make use of `org.testfx.api.FxRobot`
			// This hijacks a user's cursor for the duration of the tests, which may be undesirable
			if (project.hasProperty("excludeRobotTests")) {
				excludeTags 'robot'
			}
		}
	}
}

project(":core") {
	project.ext.mainClassName = null
	project.ext.artifactId = "fxfightstage"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	jar.manifest.attributes (
		  'Automatic-Module-Name': 'name.rayrobdod.fightStage.core'
		, 'Implementation-Title': project.ext.artifactId
	)
}

project(":demo") {
	project.ext.mainClassName = null
	project.ext.artifactId = "fxfightstage-demo"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	//TODO: convert to linksOffline after deciding where these will be online
	javadoc.options.links(project(":core").javadoc.destinationDir.toURI().toString())
	
	dependencies {
		compile project(":core")
	}
	
	jar.manifest.attributes (
		  'Automatic-Module-Name': 'name.rayrobdod.fightStage.demo'
		, 'Implementation-Title': project.ext.artifactId
	)
}

project(":samples") {
	project.ext.mainClassName = "name.rayrobdod.fightStage.previewer.Main"
	project.ext.artifactId = "fxfightstage-samples"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	//TODO: convert to linksOffline after deciding where these will be online
	javadoc.options.links(project(":core").javadoc.destinationDir.toURI().toString())
	javadoc.options.links(project(":demo").javadoc.destinationDir.toURI().toString())
	//javadoc.options.showFromPrivate()
	
	dependencies {
		compile project(":core")
		compile project(":demo")
		testCompile project(":core").sourceSets.test.output
	}
	
	
	// https://github.com/gradle/gradle/tree/master/subprojects/docs/src/samples/customModel/languageType
	// The 'create a new source directory set' part doesn't seem to work though
	task compileTemplateJava(type: TemplateJavaCompile) {
		source project.file("src/main/templates-java/name/rayrobdod/fightStage/unitAnimationGroup/infantryLancer/")
		targetDir project.file("${buildDir}/generated/java/")
	}
	tasks.withType(JavaCompile) { compileTask -> compileTask.dependsOn compileTemplateJava }
	sourceSets.main.java.srcDir "${buildDir}/generated/java/"
	
	
	
	jar.manifest.attributes (
		  'Main-Class': project.mainClassName
		, 'Automatic-Module-Name': 'name.rayrobdod.fightStage.samples'
		, 'Implementation-Title': project.ext.artifactId
	)
	
	task run(dependsOn: classes, type: JavaExec) {
		main = project.mainClassName
		classpath = sourceSets.main.runtimeClasspath
		args = splitIntoTokens(project.hasProperty("args") ? project.args : "")
		standardInput = System.in
		ignoreExitValue = true
	}
	
	//example: `gradlew runRasterize "-Pargs=--spell=Tornado --d=out.png --fps=60 --bitDepth=8 --no-smooth"`
	task runRasterize(dependsOn: classes, type: JavaExec) {
		main = "name.rayrobdod.fightStage.rasterizer.Main"
		classpath = sourceSets.main.runtimeClasspath
		args = splitIntoTokens(project.hasProperty("args") ? project.args : "")
		standardInput = System.in
		ignoreExitValue = true
	}
	
	task fatjar(dependsOn: classes, type: Jar) {
		// delay execution of expandZips unitil after the classpath is created
		from({ -> expandZips(sourceSets.main.runtimeClasspath)})
		baseName = "FxFightStageSamples"
		version = null
		destinationDir(project.distsDir)
		manifest.attributes (
			  'Main-Class': project.mainClassName
			, 'Implementation-Title': (project.ext.artifactId + "-fatjar")
			, 'Implementation-Version': project.version
			, 'Implementation-Vendor': project.group
		)
	}
	assemble.dependsOn(fatjar)
}

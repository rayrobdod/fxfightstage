plugins {
	id "com.diffplug.gradle.spotless" version "3.10.0"
}

/**
 * Create a new FileCollection that is similar to the input, but replaces any
 * non-directories (assumed to be zip files) with it's contents
 */
def expandZips(FileCollection inputs) {
	FileCollection retval = files()
	inputs.forEach{f ->
		if (f.isDirectory()) {
			retval = retval + files(f)
		} else {
			retval = retval + zipTree(f)
		}
	}
	return retval;
}

/**
 * Split a string by whitespace, taking quoting and escaping into account
 * @see https://stackoverflow.com/questions/20410854/how-to-pass-parameters-or-arguments-into-a-gradle-task/48370451#48370451
 */
def List<String> splitIntoTokens(String commandLine) {
	String regex = "(([\"']).*?\\2|(?:[^\\\\ ]+\\\\\\s+)+[^\\\\ ]+|\\S+)";
	java.util.regex.Matcher matcher = java.util.regex.Pattern.compile(regex).matcher(commandLine);
	ArrayList<String> result = new ArrayList<>();
	while (matcher.find()) {
		result.add(matcher.group());
	}
	return result
}

subprojects {
	apply plugin: 'java'
	apply plugin: 'maven'
	apply plugin: "com.diffplug.gradle.spotless"
	
	sourceCompatibility = 1.8
	[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
	[compileJava, compileTestJava]*.options*.deprecation = true
	[compileJava, compileTestJava]*.options*.compilerArgs = ["-Xlint:unchecked"]
	
	group = "name.rayrobdod"
	version = 'SNAPSHOT'
	javadoc.options.overview = new File(sourceSets.main.java.srcDirs[0], 'overview.html')
	javadoc.options.links("https://docs.oracle.com/javase/8/docs/api/")
	javadoc.options.links("https://docs.oracle.com/javase/8/javafx/api/")
	
	repositories {
		mavenCentral()
	}
	
	dependencies {
		testCompile("org.junit.jupiter:junit-jupiter-api:5.1.0")
		testRuntime("org.junit.jupiter:junit-jupiter-engine:5.1.0")
		testCompile "org.testfx:testfx-junit5:4.0.13-alpha"
	}

	spotless {
		java {
			target project.fileTree(project.rootDir) {
				include '**/*.java'
				exclude '**/generated/**/*.*'
			}
			importOrder 'java', 'javax', 'javafx', 'org.junit', 'org.testfx', '', 'name.rayrobdod'
			removeUnusedImports()
			licenseHeaderFile '../spotless-license-java'
			endWithNewline()
			replaceRegex 'one blank line after package line', '(package .+;)\n+import', '$1\n\nimport'
			replaceRegex 'one blank line after import lists', '(import .+;\n\n)\n+', '$1'
		}
	}
	
	jar.manifest.attributes (
		  'Implementation-Title': name
		, 'Implementation-Version': version
		, 'Implementation-Vendor': group
	)
	
	task javadocJar(dependsOn: javadoc, type: Jar) {
		from(javadoc.destinationDir)
		destinationDir(project.libsDir)
		classifier("javadoc")
	}
	assemble.dependsOn(javadocJar)
	task javadocTar(dependsOn: javadoc, type: Tar) {
		from(javadoc.destinationDir)
		destinationDir(project.libsDir)
		classifier("javadoc")
		compression(Compression.GZIP)
		extension("tar.gz")
	}
	assemble.dependsOn(javadocTar)
	task sourceJar(type: Jar) {
		from(sourceSets.main.allSource)
		destinationDir(project.libsDir)
		classifier("sources")
	}
	assemble.dependsOn(sourceJar)
	task sourceTar(type: Tar) {
		from(sourceSets.main.allSource)
		destinationDir(project.libsDir)
		classifier("sources")
		compression(Compression.GZIP)
		extension("tar.gz")
	}
	assemble.dependsOn(sourceTar)
	
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives {
			repositories {
				mavenDeployer {
					repository(url: localPublishLocation)
					pom.groupId = project.group
					pom.version = project.version
				}
			}
		}
	}
	
	artifacts {
		archives javadocJar
		archives sourceJar
	}
	
	// Run the thing that will tell me why the java will not compile
	// before running the thing that doesn't tell my why the java
	//     will not compile and prevents the first thing from running
	tasks.withType(com.diffplug.gradle.spotless.SpotlessTask) {mtask ->
		mtask.mustRunAfter(compileJava)
		mtask.mustRunAfter(compileTestJava)
	}
	
	test {
		enableAssertions = true
		useJUnitPlatform {
			// the `robot` tag refers to tests that make use of `org.testfx.api.FxRobot`
			// This hijacks a user's cursor for the duration of the tests, which may be undesirable
			if (project.hasProperty("excludeRobotTests")) {
				excludeTags 'robot'
			}
		}
	}
}

project(":core") {
	project.ext.mainClassName = null
	project.ext.artifactId = "fxfightstage"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	jar.manifest.attributes (
		  'Automatic-Module-Name': 'name.rayrobdod.fightStage.core'
		, 'Implementation-Title': project.ext.artifactId
	)
}

project(":demo") {
	project.ext.mainClassName = null
	project.ext.artifactId = "fxfightstage-demo"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	//TODO: convert to linksOffline after deciding where these will be online
	javadoc.options.links(project(":core").javadoc.destinationDir.toURI().toString())
	
	dependencies {
		compile project(":core")
	}
	
	jar.manifest.attributes (
		  'Automatic-Module-Name': 'name.rayrobdod.fightStage.demo'
		, 'Implementation-Title': project.ext.artifactId
	)
}

project(":samples") {
	project.ext.mainClassName = "name.rayrobdod.fightStage.previewer.Main"
	project.ext.artifactId = "fxfightstage-samples"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	//TODO: convert to linksOffline after deciding where these will be online
	javadoc.options.links(project(":core").javadoc.destinationDir.toURI().toString())
	javadoc.options.links(project(":demo").javadoc.destinationDir.toURI().toString())
	//javadoc.options.showFromPrivate()
	
	dependencies {
		compile project(":core")
		compile project(":demo")
		testCompile project(":core").sourceSets.test.output
	}
	
	task genLancerControlPoints {
		doLast {
			List<String> fields = [
				"leftFoot", "rightFoot", "leftKnee", "rightKnee", "leftPelvic", "rightPelvic",
				"leftHand", "rightHand", "leftElbow", "rightElbow", "leftShoulder", "rightShoulder",
				"head", "lanceCenter", "lanceControl"
			]
			String decl = fields.stream().map({s -> "public final Point2D ${s};"}).collect(java.util.stream.Collectors.joining())
			String initPoly1 = fields.stream().map({s -> "final Point2D ${s}"}).collect(java.util.stream.Collectors.joining(","))
			String initPoly2 = fields.stream().map({s -> "this.$s = $s;"}).collect(java.util.stream.Collectors.joining())
			String initUnary = fields.stream().map({s -> "value"}).collect(java.util.stream.Collectors.joining(", ", "this(", ");"))
			String zipMap = fields.stream().map({s -> "op.apply(this.$s, rhs.$s)"}).collect(java.util.stream.Collectors.joining(", "))
			String map = fields.stream().map({s -> "op.apply(this.$s)"}).collect(java.util.stream.Collectors.joining(", "))
			String tostr = fields.stream().map({s -> " \"${s}: \" + ${s}"}).collect(java.util.stream.Collectors.joining(" + \",\" +\n"));
			
			String copy = fields.stream().map({outer ->
				String outerTitle = "${outer.charAt(0).toUpperCase()}${outer.substring(1)}"
				fields.stream().map({inner -> (inner == outer ? "value" : inner)}).collect(java.util.stream.Collectors.joining(
					", ", "public LancerControlPoints copyWith$outerTitle(Point2D value) {return new LancerControlPoints(", ");}"
				))
			}).collect(java.util.stream.Collectors.joining("\n"))
			
			File lancerControlPointsOutDirFile = project.file("${buildDir}/generated/main/java/")
			lancerControlPointsOutDirFile.mkdirs()
			new File(lancerControlPointsOutDirFile, "LancerControlPoints.java").write """
				package name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer;
				import java.util.Map;
				import java.util.function.BinaryOperator;
				import java.util.function.UnaryOperator;
				import javafx.animation.Interpolator;
				import javafx.animation.KeyFrame;
				import javafx.animation.KeyValue;
				import javafx.beans.value.WritableDoubleValue;
				import javafx.geometry.Point2D;
				import javafx.util.Duration;
				final class LancerControlPoints implements LancerControlPointsOps {
					${decl}
					public LancerControlPoints($initPoly1) {$initPoly2}
					public LancerControlPoints(Point2D value) {$initUnary}
					
					public LancerControlPoints self() {return this;}
					public LancerControlPoints zipMap(LancerControlPoints rhs, BinaryOperator<Point2D> op) {
						return new LancerControlPoints( $zipMap );
					}
					public LancerControlPoints map(UnaryOperator<Point2D> op) {
						return new LancerControlPoints( $map );
					}
					
					$copy
					
					@Override public String toString() {return "LancerControlPoints [" + $tostr + "]"; }
				}
			"""
		}
	}
	task genLancerWritableControlPoints {
		doLast {
			List<String> fields = [
				"leftFoot", "rightFoot", "leftKnee", "rightKnee", "leftPelvic", "rightPelvic",
				"leftHand", "rightHand", "leftElbow", "rightElbow", "leftShoulder", "rightShoulder",
				"head", "lanceCenter", "lanceControl"
			]
			String decl = fields.stream().map({s -> "public final WritablePoint2dValue $s = new WritablePoint2dValue();\n"}).collect(java.util.stream.Collectors.joining())
			
			
			File lancerControlPointsOutDirFile = project.file("${buildDir}/generated/main/java/")
			lancerControlPointsOutDirFile.mkdirs()
			new File(lancerControlPointsOutDirFile, "WritableLancerControlPoints.java").write """
				package name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer;
				import javafx.geometry.Point2D;
				final class WritableLancerControlPoints implements WritableLancerControlPointsOps {
					${decl}
					public WritableLancerControlPoints self() {return this;}
				}
			"""
		}
	}
	task genLancerTimelineBuilder {
		doLast {
			List<String> fields = [
				"leftFoot", "rightFoot", "leftKnee", "rightKnee", "leftPelvic", "rightPelvic",
				"leftHand", "rightHand", "leftElbow", "rightElbow", "leftShoulder", "rightShoulder",
				"head", "lanceCenter", "lanceControl"
			]
			String decl = fields.stream().map({s -> "public final WritablePoint2dValue $s = new WritablePoint2dValue();\n"}).collect(java.util.stream.Collectors.joining())
			String firstKeyFrame = fields.stream().flatMap({attr ->
				java.util.stream.Stream.of("X", "Y").map({dir ->
					"new KeyValue(keys.${attr}.writable${dir}, values.${attr}.get${dir}(), Interpolator.DISCRETE)"
				})
			}).collect(java.util.stream.Collectors.joining(",\n"))
			
			String appendSet = fields.stream().map({s ->
				String sTitle = "${s.charAt(0).toUpperCase()}${s.substring(1)}"
				"""public void appendSet${sTitle}(Point2D value, Duration time, Interpolator interp) {
					this.values = this.values.copyWith${sTitle}(value);
					this.timeline.add(new KeyFrame(time,
						new KeyValue(keys.${s}.writableX, value.getX(), interp),
						new KeyValue(keys.${s}.writableY, value.getY(), interp)
					));
				}
				"""
			}).collect(java.util.stream.Collectors.joining())
			String appendAdd = fields.stream().map({s ->
				String sTitle = "${s.charAt(0).toUpperCase()}${s.substring(1)}"
				"""public void appendAdd${sTitle}(Point2D value, Duration time, Interpolator interp) {
					this.appendSet${sTitle}(this.values.${s}.add(value), time, interp);
				}
				"""
			}).collect(java.util.stream.Collectors.joining())
			String storeInMap = fields.stream().flatMap({attr ->
				java.util.stream.Stream.of("X", "Y").map({dir ->
					"store.put(keys.${attr}.writable${dir}, values.${attr}.get${dir}());"
				})
			}).collect(java.util.stream.Collectors.joining())
			String extract = fields.stream().map(
				{s -> """new Point2D(store.get(keys.${s}.writableX), store.get(keys.${s}.writableY))"""}
			).collect(java.util.stream.Collectors.joining(",\n"))
			
			
			File lancerControlPointsOutDirFile = project.file("${buildDir}/generated/main/java/")
			lancerControlPointsOutDirFile.mkdirs()
			new File(lancerControlPointsOutDirFile, "LancerTimelineBuilder.java").write """
				package name.rayrobdod.fightStage.unitAnimationGroup.infantryLancer;
				import java.util.Map;
				import javafx.animation.Interpolator;
				import javafx.animation.KeyFrame;
				import javafx.animation.KeyValue;
				import javafx.animation.Timeline;
				import javafx.beans.value.WritableDoubleValue;
				import javafx.geometry.Point2D;
				import javafx.util.Duration;
				final class LancerTimelineBuilder {
					private final WritableLancerControlPoints keys;
					private LancerControlPoints values;
					private final java.util.ArrayList<KeyFrame> timeline;
					
					public LancerTimelineBuilder(WritableLancerControlPoints keys, LancerControlPoints initialValues) {
						this.keys = keys;
						this.values = initialValues;
						this.timeline = new java.util.ArrayList<>();
						
						this.timeline.add(new KeyFrame(Duration.ZERO, $firstKeyFrame));
					}
					
					public LancerTimelineBuilder(WritableLancerControlPoints keys, Map<WritableDoubleValue, Double> store) {
						this(keys, extractFromMap(store, keys));
					}
					
					public LancerControlPoints currentValues() {return values;}
					public Timeline timeline() {return new Timeline(timeline.stream().toArray(KeyFrame[]::new));}
					
					public void storeInMap(Map<WritableDoubleValue, Double> store) {
						$storeInMap
					}
					
					private static LancerControlPoints extractFromMap(Map<WritableDoubleValue, Double> store, WritableLancerControlPoints keys) {
						return new LancerControlPoints($extract);
					}
					
					$appendSet
					$appendAdd
				}
			"""
		}
	}
	tasks.withType(JavaCompile) { compileTask -> compileTask.dependsOn genLancerControlPoints }
	tasks.withType(JavaCompile) { compileTask -> compileTask.dependsOn genLancerWritableControlPoints }
	tasks.withType(JavaCompile) { compileTask -> compileTask.dependsOn genLancerTimelineBuilder }
	sourceSets.main.java.srcDir "${buildDir}/generated/main/java/"
	
	jar.manifest.attributes (
		  'Main-Class': project.mainClassName
		, 'Automatic-Module-Name': 'name.rayrobdod.fightStage.samples'
		, 'Implementation-Title': project.ext.artifactId
	)
	
	task run(dependsOn: classes, type: JavaExec) {
		main = project.mainClassName
		classpath = sourceSets.main.runtimeClasspath
		args = splitIntoTokens(project.hasProperty("args") ? project.args : "")
		standardInput = System.in
		ignoreExitValue = true
	}
	
	//example: `gradlew runRasterize "-Pargs=--spell=Tornado --d=out.png --fps=60 --bitDepth=8 --no-smooth"`
	task runRasterize(dependsOn: classes, type: JavaExec) {
		main = "name.rayrobdod.fightStage.rasterizer.Main"
		classpath = sourceSets.main.runtimeClasspath
		args = splitIntoTokens(project.hasProperty("args") ? project.args : "")
		standardInput = System.in
		ignoreExitValue = true
	}
	
	task fatjar(dependsOn: classes, type: Jar) {
		// delay execution of expandZips unitil after the classpath is created
		from({ -> expandZips(sourceSets.main.runtimeClasspath)})
		baseName = "FxFightStageSamples"
		version = null
		destinationDir(project.distsDir)
		manifest.attributes (
			  'Main-Class': project.mainClassName
			, 'Implementation-Title': (project.ext.artifactId + "-fatjar")
			, 'Implementation-Version': project.version
			, 'Implementation-Vendor': project.group
		)
	}
	assemble.dependsOn(fatjar)
}

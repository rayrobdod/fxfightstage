buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath 'org.junit.platform:junit-platform-gradle-plugin:1.0.2'
	}
}

plugins {
	id "com.diffplug.gradle.spotless" version "3.6.0"
}

/**
 * Create a new FileCollection that is similar to the input, but replaces any
 * non-directories (assumed to be zip files) with it's contents
 */
def expandZips(FileCollection inputs) {
	FileCollection retval = files()
	inputs.forEach{f ->
		if (f.isDirectory()) {
			retval = retval + files(f)
		} else {
			retval = retval + zipTree(f)
		}
	}
	return retval;
}

subprojects {
	apply plugin: 'java'
	apply plugin: 'maven'
	apply plugin: 'org.junit.platform.gradle.plugin'
	apply plugin: "com.diffplug.gradle.spotless"
	
	sourceCompatibility = 1.8
	[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
	[compileJava, compileTestJava]*.options*.deprecation = true
	[compileJava, compileTestJava]*.options*.compilerArgs = ["-Xlint:unchecked"]
	
	group = "name.rayrobdod"
	version = 'SNAPSHOT'
	javadoc.options.overview = new File(sourceSets.main.java.srcDirs[0], 'overview.html')
	javadoc.options.links("https://docs.oracle.com/javase/8/docs/api/")
	javadoc.options.links("https://docs.oracle.com/javase/8/javafx/api/")
	
	repositories {
		mavenCentral()
	}
	
	dependencies {
		testCompile("org.junit.jupiter:junit-jupiter-api:5.0.2")
		testRuntime("org.junit.jupiter:junit-jupiter-engine:5.0.2")
		testCompile "org.testfx:testfx-junit5:4.0.11-alpha"
	}

	spotless {
		java {
			importOrder 'java', 'javax', 'javafx', 'org.junit', 'org.testfx', '', 'name.rayrobdod'
			removeUnusedImports()
			licenseHeaderFile '../spotless-license-java'
			endWithNewline()
			replaceRegex 'one blank line after package line', '(package .+;)\n+import', '$1\n\nimport'
		}
	}
	
	jar.manifest.attributes (
		  'Implementation-Title': name
		, 'Implementation-Version': version
		, 'Implementation-Vendor': group
	)
	
	task javadocJar(dependsOn: javadoc, type: Jar) {
		from(javadoc.destinationDir)
		destinationDir(project.libsDir)
		classifier("javadoc")
	}
	assemble.dependsOn(javadocJar)
	task javadocTar(dependsOn: javadoc, type: Tar) {
		from(javadoc.destinationDir)
		destinationDir(project.libsDir)
		classifier("javadoc")
		compression(Compression.GZIP)
		extension("tar.gz")
	}
	assemble.dependsOn(javadocTar)
	task sourceJar(type: Jar) {
		from(sourceSets.main.allSource)
		destinationDir(project.libsDir)
		classifier("sources")
	}
	assemble.dependsOn(sourceJar)
	task sourceTar(type: Tar) {
		from(sourceSets.main.allSource)
		destinationDir(project.libsDir)
		classifier("sources")
		compression(Compression.GZIP)
		extension("tar.gz")
	}
	assemble.dependsOn(sourceTar)
	
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives {
			repositories {
				mavenDeployer {
					repository(url: localPublishLocation)
					pom.groupId = project.group
					pom.version = project.version
				}
			}
		}
	}
	
	artifacts {
		archives javadocJar
		archives sourceJar
	}
	
	// Run the thing that will tell me why the java will not compile
	// before running the thing that doesn't tell my why the java
	//     will not compile and prevents the first thing from running
	tasks.withType(com.diffplug.gradle.spotless.SpotlessTask) {mtask ->
		mtask.mustRunAfter(compileJava)
		mtask.mustRunAfter(compileTestJava)
	}
	
	junitPlatform {
		filters {
			tags {
				// the `image` tag refers to tests that require internal fx graphics to be initialized to run
				// the `robot` tag refers to tests that make use of `org.testfx.api.FxRobot`
				
				// Tests with either of these tags will not run in a headless environment
				if (project.hasProperty("enableAllJunitTags")) {
					// do nothing
				} else {
					exclude 'image', 'robot'
				}
			}
		}
	}
}

project(":core") {
	project.ext.mainClassName = null
	project.ext.artifactId = "fxfightstage"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	jar.manifest.attributes (
		  'Automatic-Module-Name': 'name.rayrobdod.fightStage.core'
		, 'Implementation-Title': project.ext.artifactId
	)
}

project(":demo") {
	project.ext.mainClassName = null
	project.ext.artifactId = "fxfightstage-demo"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	//TODO: convert to linksOffline after deciding where these will be online
	javadoc.options.links(project(":core").javadoc.destinationDir.toURI().toString())
	
	dependencies {
		compile project(":core")
	}
	
	jar.manifest.attributes (
		  'Automatic-Module-Name': 'name.rayrobdod.fightStage.demo'
		, 'Implementation-Title': project.ext.artifactId
	)
}

project(":samples") {
	project.ext.mainClassName = "name.rayrobdod.fightStage.previewer.Main"
	project.ext.artifactId = "fxfightstage-samples"
	if (project.hasProperty("localPublishLocation")) {
		uploadArchives.repositories.mavenDeployer.pom.artifactId = project.ext.artifactId
	}
	
	//TODO: convert to linksOffline after deciding where these will be online
	javadoc.options.links(project(":core").javadoc.destinationDir.toURI().toString())
	javadoc.options.links(project(":demo").javadoc.destinationDir.toURI().toString())
	
	dependencies {
		compile project(":core")
		compile project(":demo")
		testCompile project(":core").sourceSets.test.output
	}
	
	jar.manifest.attributes (
		  'Main-Class': project.mainClassName
		, 'Automatic-Module-Name': 'name.rayrobdod.fightStage.samples'
		, 'Implementation-Title': project.ext.artifactId
	)
	
	task run(dependsOn: classes, type: JavaExec) {
		main = project.mainClassName
		classpath = sourceSets.main.runtimeClasspath
		standardInput = System.in
		ignoreExitValue = true
	}
	
	task fatjar(dependsOn: classes, type: Jar) {
		// delay execution of expandZips unitil after the classpath is created
		from({ -> expandZips(sourceSets.main.runtimeClasspath)})
		baseName = "FxFightStageSamples"
		version = null
		destinationDir(project.distsDir)
		manifest.attributes (
			  'Main-Class': project.mainClassName
			, 'Implementation-Title': (project.ext.artifactId + "-fatjar")
			, 'Implementation-Version': project.version
			, 'Implementation-Vendor': project.group
		)
	}
	assemble.dependsOn(fatjar)
}
